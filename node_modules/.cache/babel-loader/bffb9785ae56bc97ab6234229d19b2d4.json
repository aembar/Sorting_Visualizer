{"ast":null,"code":"export function getHeapSortAnimations(array){var animations=[];heapSort(array,animations);return animations;}function heapSort(arr,animations){var arrLength=arr.length;for(var i=Math.floor(arrLength/2);i>=0;i--){//builds the max heap by making all parent node bigger than child node\n//this initialize and turns the array into a max heap for the first time\n//i is the index of the item that has child node(for odd num) and therefore worth checking\n//we fills the heap with index from zero to max, from left to right across the levels\nheapify(arr,i,arrLength,animations);}for(i=arrLength-1;i>0;i--){//now that we have a max heap, we continually exchanges the root node with the last node\n//and removes the last node which contains the max value and therefore considered sorted\nswap(arr,0,i,animations);//after the swap, the root node may no longer be the biggest value, hence required heapify.\n//since last node is sorted, reduce the array length by one\narrLength--;heapify(arr,0,arrLength,animations);}}function heapify(arr,idx,arrLength,animations){var leftIdx=2*idx+1;var rightIdx=2*idx+2;//check if the parent node is bigger than child node\nvar max=idx;if(leftIdx<arrLength&&arr[leftIdx]>arr[max]){animations.push([leftIdx,max]);animations.push([leftIdx,max]);animations.push([0,arr[0]]);animations.push([0,arr[0]]);max=leftIdx;// if left exists and bigger\n}if(rightIdx<arrLength&&arr[rightIdx]>arr[max]){animations.push([rightIdx,max]);animations.push([rightIdx,max]);animations.push([0,arr[0]]);animations.push([0,arr[0]]);max=rightIdx;// if right exists and bigger\n}if(max!==idx){// if needs to change\nswap(arr,idx,max,animations);heapify(arr,max,arrLength,animations);// recursive to the end for the root node\n}}function swap(arr,firstIdx,lastIdx,animations){animations.push([firstIdx,lastIdx]);animations.push([firstIdx,lastIdx]);animations.push([firstIdx,arr[lastIdx]]);animations.push([lastIdx,arr[firstIdx]]);var temp=arr[firstIdx];arr[firstIdx]=arr[lastIdx];arr[lastIdx]=temp;}","map":{"version":3,"sources":["/Users/adithya/Documents/Sorting_Visualizer/src/sortingAlgorithms/heapSort.js"],"names":["getHeapSortAnimations","array","animations","heapSort","arr","arrLength","length","i","Math","floor","heapify","swap","idx","leftIdx","rightIdx","max","push","firstIdx","lastIdx","temp"],"mappings":"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","sourcesContent":["export function getHeapSortAnimations(array) {\n    const animations = [];\n    heapSort(array, animations);\n    return animations;\n  }\n  \n  function heapSort(arr, animations) {\n    var arrLength = arr.length;\n    for (var i = Math.floor(arrLength / 2); i >= 0; i--) {\n      //builds the max heap by making all parent node bigger than child node\n      //this initialize and turns the array into a max heap for the first time\n      //i is the index of the item that has child node(for odd num) and therefore worth checking\n      //we fills the heap with index from zero to max, from left to right across the levels\n      heapify(arr, i, arrLength, animations);\n    }\n  \n    for (i = arrLength - 1; i > 0; i--) {\n      //now that we have a max heap, we continually exchanges the root node with the last node\n      //and removes the last node which contains the max value and therefore considered sorted\n      swap(arr, 0, i, animations);\n      //after the swap, the root node may no longer be the biggest value, hence required heapify.\n      //since last node is sorted, reduce the array length by one\n      arrLength--;\n      heapify(arr, 0, arrLength, animations);\n    }\n  }\n  \n  function heapify(arr, idx, arrLength, animations) {\n    var leftIdx = 2 * idx + 1;\n    var rightIdx = 2 * idx + 2;\n    //check if the parent node is bigger than child node\n    var max = idx;\n    if (leftIdx < arrLength && arr[leftIdx] > arr[max]) {\n      animations.push([leftIdx, max]);\n      animations.push([leftIdx, max]);\n      animations.push([0, arr[0]]);\n      animations.push([0, arr[0]]);\n      max = leftIdx; // if left exists and bigger\n    }\n    if (rightIdx < arrLength && arr[rightIdx] > arr[max]) {\n      animations.push([rightIdx, max]);\n      animations.push([rightIdx, max]);\n      animations.push([0, arr[0]]);\n      animations.push([0, arr[0]]);\n      max = rightIdx; // if right exists and bigger\n    }\n    if (max !== idx) {\n      // if needs to change\n      swap(arr, idx, max, animations);\n      heapify(arr, max, arrLength, animations); // recursive to the end for the root node\n    }\n  }\n  \n  function swap(arr, firstIdx, lastIdx, animations) {\n    animations.push([firstIdx, lastIdx]);\n    animations.push([firstIdx, lastIdx]);\n    animations.push([firstIdx, arr[lastIdx]]);\n    animations.push([lastIdx, arr[firstIdx]]);\n    var temp = arr[firstIdx];\n    arr[firstIdx] = arr[lastIdx];\n    arr[lastIdx] = temp;\n  }"]},"metadata":{},"sourceType":"module"}