{"ast":null,"code":"export function getHeapSortAnimations(array) {\n  const animations = [];\n  heapSort(array, animations);\n  return animations;\n}\n\nfunction heapSort(arr, animations) {\n  var arrLength = arr.length;\n\n  for (var i = Math.floor(arrLength / 2); i >= 0; i--) {\n    //builds the max heap by making all parent node bigger than child node\n    //this initialize and turns the array into a max heap for the first time\n    //i is the index of the item that has child node(for odd num) and therefore worth checking\n    //we fills the heap with index from zero to max, from left to right across the levels\n    heapify(arr, i, arrLength, animations);\n  }\n\n  for (i = arrLength - 1; i > 0; i--) {\n    //now that we have a max heap, we continually exchanges the root node with the last node\n    //and removes the last node which contains the max value and therefore considered sorted\n    swap(arr, 0, i, animations); //after the swap, the root node may no longer be the biggest value, hence required heapify.\n    //since last node is sorted, reduce the array length by one\n\n    arrLength--;\n    heapify(arr, 0, arrLength, animations);\n  }\n}\n\nfunction heapify(arr, idx, arrLength, animations) {\n  var leftIdx = 2 * idx + 1;\n  var rightIdx = 2 * idx + 2; //check if the parent node is bigger than child node\n\n  var max = idx;\n\n  if (leftIdx < arrLength && arr[leftIdx] > arr[max]) {\n    animations.push([leftIdx, max]);\n    animations.push([leftIdx, max]);\n    animations.push([0, arr[0]]);\n    animations.push([0, arr[0]]);\n    max = leftIdx; // if left exists and bigger\n  }\n\n  if (rightIdx < arrLength && arr[rightIdx] > arr[max]) {\n    animations.push([rightIdx, max]);\n    animations.push([rightIdx, max]);\n    animations.push([0, arr[0]]);\n    animations.push([0, arr[0]]);\n    max = rightIdx; // if right exists and bigger\n  }\n\n  if (max !== idx) {\n    // if needs to change\n    swap(arr, idx, max, animations);\n    heapify(arr, max, arrLength, animations); // recursive to the end for the root node\n  }\n}\n\nfunction swap(arr, firstIdx, lastIdx, animations) {\n  animations.push([firstIdx, lastIdx]);\n  animations.push([firstIdx, lastIdx]);\n  animations.push([firstIdx, arr[lastIdx]]);\n  animations.push([lastIdx, arr[firstIdx]]);\n  var temp = arr[firstIdx];\n  arr[firstIdx] = arr[lastIdx];\n  arr[lastIdx] = temp;\n}","map":{"version":3,"sources":["/Users/adithya/Documents/Sorting_Visualizer/src/sortingAlgorithms/heapSort.js"],"names":["getHeapSortAnimations","array","animations","heapSort","arr","arrLength","length","i","Math","floor","heapify","swap","idx","leftIdx","rightIdx","max","push","firstIdx","lastIdx","temp"],"mappings":"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","sourcesContent":["export function getHeapSortAnimations(array) {\n    const animations = [];\n    heapSort(array, animations);\n    return animations;\n  }\n  \n  function heapSort(arr, animations) {\n    var arrLength = arr.length;\n    for (var i = Math.floor(arrLength / 2); i >= 0; i--) {\n      //builds the max heap by making all parent node bigger than child node\n      //this initialize and turns the array into a max heap for the first time\n      //i is the index of the item that has child node(for odd num) and therefore worth checking\n      //we fills the heap with index from zero to max, from left to right across the levels\n      heapify(arr, i, arrLength, animations);\n    }\n  \n    for (i = arrLength - 1; i > 0; i--) {\n      //now that we have a max heap, we continually exchanges the root node with the last node\n      //and removes the last node which contains the max value and therefore considered sorted\n      swap(arr, 0, i, animations);\n      //after the swap, the root node may no longer be the biggest value, hence required heapify.\n      //since last node is sorted, reduce the array length by one\n      arrLength--;\n      heapify(arr, 0, arrLength, animations);\n    }\n  }\n  \n  function heapify(arr, idx, arrLength, animations) {\n    var leftIdx = 2 * idx + 1;\n    var rightIdx = 2 * idx + 2;\n    //check if the parent node is bigger than child node\n    var max = idx;\n    if (leftIdx < arrLength && arr[leftIdx] > arr[max]) {\n      animations.push([leftIdx, max]);\n      animations.push([leftIdx, max]);\n      animations.push([0, arr[0]]);\n      animations.push([0, arr[0]]);\n      max = leftIdx; // if left exists and bigger\n    }\n    if (rightIdx < arrLength && arr[rightIdx] > arr[max]) {\n      animations.push([rightIdx, max]);\n      animations.push([rightIdx, max]);\n      animations.push([0, arr[0]]);\n      animations.push([0, arr[0]]);\n      max = rightIdx; // if right exists and bigger\n    }\n    if (max !== idx) {\n      // if needs to change\n      swap(arr, idx, max, animations);\n      heapify(arr, max, arrLength, animations); // recursive to the end for the root node\n    }\n  }\n  \n  function swap(arr, firstIdx, lastIdx, animations) {\n    animations.push([firstIdx, lastIdx]);\n    animations.push([firstIdx, lastIdx]);\n    animations.push([firstIdx, arr[lastIdx]]);\n    animations.push([lastIdx, arr[firstIdx]]);\n    var temp = arr[firstIdx];\n    arr[firstIdx] = arr[lastIdx];\n    arr[lastIdx] = temp;\n  }"]},"metadata":{},"sourceType":"module"}